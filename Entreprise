import java.util.*;

public class Entreprise {
    public void GenerationDemande(HashMap<String,Boulevard> boulevard){
        Random r = new Random();
        List<Boulevard> listeBoulevards = new ArrayList<>(boulevard.values());
        Boulevard b = listeBoulevards.get(r.nextInt(listeBoulevards.size()));
        if (b.arc.size() > 0) {
            Arc rueChoisie = b.arc.get(r.nextInt(b.arc.size()));
            rueChoisie.demande = true;
        }
    }

    public void AfficherDemandes(HashMap<String, Boulevard> ville) {
        for (HashMap.Entry<String, Boulevard> entry : ville.entrySet()) {
            Boulevard b = entry.getValue();
            for (Arc a : b.arc) {
                if (Boolean.TRUE.equals(a.demande)) {
                    System.out.println("Rue en demande : " + a.nom);
                }
            }
        }
    }

    public Boulevard retournerDemande(HashMap<String, Boulevard> ville) {
        for (HashMap.Entry<String, Boulevard> entry : ville.entrySet()) {
            Boulevard b = entry.getValue();
            for (Arc a : b.arc) {
                if (Boolean.TRUE.equals(a.demande)) {
                    return b;
                }
            }
        }
        return null;
    }

    public void GenererPointCollecte(HashMap<String, Boulevard> ville) {

        // Liste des 40 sommets aléatoires
        int[] sommets = {
                312, 2840, 1187, 42, 1993, 274, 3301, 165, 2876, 904,
                1783, 2664, 59, 1449, 2390, 313, 2701, 181, 3279, 721,
                3084, 118, 349, 2540, 1902, 2210, 873, 1421, 3177, 267,
                2590, 3401, 194, 813, 1032, 2688, 152, 1436, 989, 3330
        };

        // D'abord tout mettre à false
        for (Boulevard b : ville.values()) {
            b.ptDeCollecte = false;
        }

        // Mettre à true les intersections correspondantes
        for (int id : sommets) {
            String cle = "Intersection" + id;
            Boulevard b = ville.get(cle);

            if (b != null) {
                b.ptDeCollecte = true;
            }
        }
    }


    public void dijkstra(HashMap<String, Boulevard> ville, Boulevard source) {
        for (Boulevard b : ville.values()) {
            b.temps = Integer.MAX_VALUE;
            b.arcPred = null;
            b.marque = false;
        }
        source.temps = 0;

        ArrayList<Boulevard> attente = new ArrayList<>();
        attente.add(source);

        while (!attente.isEmpty()) {
            Boulevard courant = getMin(attente);
            attente.remove(courant);
            courant.marque = true;
            for (Arc a : courant.arc) {
                Boulevard succ = a.Boulevardsuiv;
                if (!succ.marque) {
                    int nouveauTemps = courant.temps + a.temps;
                    if (nouveauTemps  < succ.temps) {
                        succ.temps = nouveauTemps;
                        succ.arcPred = a;
                        if (!attente.contains(succ)) {
                            attente.add(succ);
                        }
                    }
                }
            }
        }
    }

    public void afficherChemin(Boulevard destination) {
        if (destination == null) {
            System.out.println("Boulevard introuvable.");
            return;
        }
        if (destination.temps == Integer.MAX_VALUE) {
            System.out.println("Aucun chemin trouvé jusqu’à " + destination.nom);
            return;
        }
        ArrayList<String> chemin = new ArrayList<>();
        Boulevard courant = destination;

        while (courant != null) {
            chemin.add(0, courant.nom); // On ajoute au début pour inverser l’ordre
            if (courant.arcPred != null)
                courant = courant.arcPred.Boulevardprec;
            else
                break;
        }
        System.out.println("Chemin le plus court :");
        for (int i = 0; i < chemin.size(); i++) {
            System.out.print(chemin.get(i));
            if (i < chemin.size() - 1) System.out.print(" -> ");
        }
        System.out.println("\nTemps total : " + destination.temps);
    }

    public Boulevard getMin(ArrayList<Boulevard> liste) {
        Boulevard min = null;
        int meilleurTemps = Integer.MAX_VALUE;

        for (Boulevard b : liste) {
            if (b.temps < meilleurTemps) {
                meilleurTemps = b.temps;
                min = b;
            }
        }
        return min;
    }

    public Arc getMinArc(Boulevard b) {
        Arc minArc = b.arc.get(0);
        for (Arc a : b.arc) {
            if (a.temps < minArc.temps) {
                minArc = a;
            }
        }
        return minArc;
    }

    //première version avec Djirka
    public void Parcours(HashMap<String, Boulevard> ville, Boulevard source) {
        Boulevard courant = source;
        int tempsTotal = 0;

        ArrayList<String> cheminGlobal = new ArrayList<>();
        cheminGlobal.add(courant.nom);

        ArrayList<Arc> demandes = new ArrayList<>();
        for (Boulevard b : ville.values()) {
            for (Arc a : b.arc) {
                if (Boolean.TRUE.equals(a.demande)) {
                    demandes.add(a);
                }
            }
        }

        while (!demandes.isEmpty()) {

            dijkstra(ville, courant);
            Arc meilleureRue = TrouverMeilleurTemps(demandes);
            if (meilleureRue == null) {
                System.out.println("Impossible d'atteindre toutes les rues en demande.");
                break;
            }

            Boulevard departRue = meilleureRue.Boulevardprec;
            Boulevard arriveeRue = meilleureRue.Boulevardsuiv;

            ArrayList<String> sousChemin = reconstruireChemin(departRue);

            if (sousChemin.isEmpty()) {
                System.out.println("Erreur : impossible de rejoindre " + departRue.nom);
                break;
            }

            for (int i = 1; i < sousChemin.size(); i++) {
                cheminGlobal.add(sousChemin.get(i));
            }

            if (!cheminGlobal.get(cheminGlobal.size() - 1).equals(arriveeRue.nom)) {
                cheminGlobal.add(arriveeRue.nom);
            }

            tempsTotal += departRue.temps + meilleureRue.temps;

            demandes.remove(meilleureRue);
            meilleureRue.demande = false;

            courant = arriveeRue;
        }

        if (!courant.equals(source)) {
            dijkstra(ville, courant);
            ArrayList<String> retour = reconstruireChemin(source);

            if (!retour.isEmpty()) {
                for (int i = 1; i < retour.size(); i++) {
                    cheminGlobal.add(retour.get(i));
                }
                tempsTotal += source.temps; // source.temps après Dijkstra(courant)
            }
        }

        System.out.println("Chemin global :");
        for (int i = 0; i < cheminGlobal.size(); i++) {
            System.out.print(cheminGlobal.get(i));
            if (i < cheminGlobal.size() - 1) System.out.print(" -> ");
        }
        System.out.println("\nTemps total : " + tempsTotal);
    }

    public Arc TrouverMeilleurTemps(ArrayList<Arc> demandes){
        Arc meilleureRue = null;
        Boulevard departRue = null;
        int meilleurTemps = Integer.MAX_VALUE;

        for (Arc a : demandes) {
            Boulevard prec = a.Boulevardprec;

            if (prec.temps == Integer.MAX_VALUE) {
                continue;
            }
            int cout = prec.temps;
            if (cout < meilleurTemps) {
                meilleurTemps = cout;
                meilleureRue = a;
                departRue = prec;

            }
        }
        return meilleureRue;
    }

    private ArrayList<String> reconstruireChemin(Boulevard destination) {
        ArrayList<String> chemin = new ArrayList<>();

        if (destination == null || destination.temps == Integer.MAX_VALUE) {
            return chemin; // chemin vide = inatteignable
        }

        Boulevard courant = destination;
        while (courant != null) {
            chemin.add(0, courant.nom); // on ajoute au début pour inverser
            if (courant.arcPred != null) {
                courant = courant.arcPred.Boulevardprec;
            } else {
                break;
            }
        }

        return chemin;
    }




    private ArrayList<Boulevard> getPointsCollecte(HashMap<String, Boulevard> ville) {
        ArrayList<Boulevard> points = new ArrayList<>();
        for (Boulevard b : ville.values()) {
            if (b.ptDeCollecte) {
                points.add(b);
            }
        }
        return points;
    }


    private int[] construireMST(int[][] dist, int racine) {
        int n = dist.length;
        int[] parent = new int[n];          // parent[i] = père de i dans l'arbre
        int[] cle = new int[n];             // poids minimal pour raccorder i
        boolean[] dansMST = new boolean[n];

        Arrays.fill(cle, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);
        cle[racine] = 0;

        for (int k = 0; k < n - 1; k++) {
            int u = -1;
            int min = Integer.MAX_VALUE;

            // choisir le sommet non encore pris avec la plus petite clé
            for (int i = 0; i < n; i++) {
                if (!dansMST[i] && cle[i] < min) {
                    min = cle[i];
                    u = i;
                }
            }

            if (u == -1) break; // graph non connexe (sécurité)

            dansMST[u] = true;

            // mise à jour des voisins
            for (int v = 0; v < n; v++) {
                if (!dansMST[v] && dist[u][v] < cle[v]) {
                    cle[v] = dist[u][v];
                    parent[v] = u;
                }
            }
        }

        return parent;
    }

    private void dfsMST(int u,
                        ArrayList<ArrayList<Integer>> adj,
                        boolean[] visite,
                        ArrayList<Integer> ordre) {
        visite[u] = true;
        ordre.add(u); // préfixe : on ajoute le sommet dès son entrée

        for (int v : adj.get(u)) {
            if (!visite[v]) {
                dfsMST(v, adj, visite, ordre);
            }
        }
    }


    public ArrayList<String> tourneeMST(HashMap<String, Boulevard> ville, Boulevard depot) {
        int tempsTotal = 0;
        int nbAretes = 0;

        ArrayList<Boulevard> points = getPointsCollecte(ville);

        // S'assurer que le dépôt est dans la liste en première position
        int indexDepot = -1;
        for (int i = 0; i < points.size(); i++) {
            if (points.get(i) == depot) {
                indexDepot = i;
                break;
            }
        }
        if (indexDepot == -1) {
            points.add(0, depot);
        } else if (indexDepot != 0) {
            Collections.swap(points, 0, indexDepot);
        }

        int n = points.size();
        if (n <= 1) {
            return new ArrayList<>();
        }

        // 2. Matrice des plus courts chemins entre tous les points
        int[][] dist = new int[n][n];

        for (int i = 0; i < n; i++) {
            Boulevard source = points.get(i);
            dijkstra(ville, source);  // met à jour .temps / .arcPred pour tous les boulevards

            for (int j = 0; j < n; j++) {
                Boulevard dest = points.get(j);
                dist[i][j] = dest.temps;
            }
        }

        // 3. Construire le MST avec Prim en prenant 0 (le dépôt) comme racine
        int[] parent = construireMST(dist, 0);

        // 4. Transformer parent[] en liste d’adjacence
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int v = 0; v < n; v++) {
            if (parent[v] != -1) {
                int p = parent[v];
                adj.get(p).add(v);
                adj.get(v).add(p); // l’arbre est non orienté
            }
        }

        // 5. Parcours préfixe du MST à partir du dépôt (0)
        boolean[] visite = new boolean[n];
        ArrayList<Integer> ordre = new ArrayList<>();
        dfsMST(0, adj, visite, ordre);

        // 6. Construire la tournée réelle dans le graphe de rues
        ArrayList<String> cheminGlobal = new ArrayList<>();
        Boulevard courant = depot;

        for (int k = 1; k < ordre.size(); k++) {
            int idx = ordre.get(k);
            Boulevard cible = points.get(idx);

            if (cible == courant) continue;

            // plus court chemin courant -> cible
            dijkstra(ville, courant);
            ArrayList<String> sousChemin = reconstruireChemin(cible);

            // Calculer temps et nombre d'arêtes du sous-chemin
            for (int x = 0; x < sousChemin.size() - 1; x++) {
                Boulevard u = ville.get(sousChemin.get(x));
                Boulevard v = ville.get(sousChemin.get(x + 1));

                // Trouver l'arc correspondant u -> v
                for (Arc a : u.arc) {
                    if (a.Boulevardsuiv == v) {
                        tempsTotal += a.temps;
                        nbAretes++;
                        break;
                    }
                }
            }


            // enlever le premier sommet pour éviter les doublons
            if (!cheminGlobal.isEmpty() && !sousChemin.isEmpty()) {
                sousChemin.remove(0);
            }

            cheminGlobal.addAll(sousChemin);
            courant = cible;
        }

        // retour au dépôt
        dijkstra(ville, courant);
        ArrayList<String> retour = reconstruireChemin(depot);
        for (int x = 0; x < retour.size() - 1; x++) {
            Boulevard u = ville.get(retour.get(x));
            Boulevard v = ville.get(retour.get(x + 1));

            for (Arc a : u.arc) {
                if (a.Boulevardsuiv == v) {
                    tempsTotal += a.temps;
                    nbAretes++;
                    break;
                }
            }
        }

        if (!retour.isEmpty()) retour.remove(0);
        System.out.println("Temps total de la tournée (MST) : " + tempsTotal + " unités");
        System.out.println("Nombre total d'arêtes parcourues : " + nbAretes);

        cheminGlobal.addAll(retour);

        return cheminGlobal;
    }

}


