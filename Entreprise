import java.util.*;

public class Entreprise {
    public void GenerationDemande(HashMap<String,Boulevard> boulevard){
        Random r = new Random();
        List<Boulevard> listeBoulevards = new ArrayList<>(boulevard.values());
        Boulevard b = listeBoulevards.get(r.nextInt(listeBoulevards.size()));
        if (b.arc.size() > 0) {
            Arc rueChoisie = b.arc.get(r.nextInt(b.arc.size()));
            rueChoisie.demande = true;
        }
    }

    public void AfficherDemandes(HashMap<String, Boulevard> ville) {
        for (HashMap.Entry<String, Boulevard> entry : ville.entrySet()) {
            Boulevard b = entry.getValue();
            for (Arc a : b.arc) {
                if (Boolean.TRUE.equals(a.demande)) {
                    System.out.println("Rue en demande : " + a.nom);
                }
            }
        }
    }

    public Boulevard retournerDemande(HashMap<String, Boulevard> ville) {
        for (HashMap.Entry<String, Boulevard> entry : ville.entrySet()) {
            Boulevard b = entry.getValue();
            for (Arc a : b.arc) {
                if (Boolean.TRUE.equals(a.demande)) {
                    return b;
                }
            }
        }
        return null;
    }

    public void GenererPointCollecte(HashMap<String, Boulevard> ville) {

        // Liste des 40 sommets aléatoires
        int[] sommets = {
                312, 2840, 1187, 42, 1993, 274, 3301, 165, 2876, 904,
                1783, 2664, 59, 1449, 2390, 313, 2701, 181, 3279, 721,
                3084, 118, 349, 2540, 1902, 2210, 873, 1421, 3177, 267,
                2590, 3401, 194, 813, 1032, 2688, 152, 1436, 989, 3330
        };

        // D'abord tout mettre à false
        for (Boulevard b : ville.values()) {
            b.ptDeCollecte = false;
        }

        // Mettre à true les intersections correspondantes
        for (int id : sommets) {
            String cle = "Intersection" + id;
            Boulevard b = ville.get(cle);

            if (b != null) {
                b.ptDeCollecte = true;
            }
        }
    }


    public void dijkstra(HashMap<String, Boulevard> ville, Boulevard source) {
        for (Boulevard b : ville.values()) {
            b.temps = Integer.MAX_VALUE;
            b.arcPred = null;
            b.marque = false;
        }
        source.temps = 0;

        ArrayList<Boulevard> attente = new ArrayList<>();
        attente.add(source);

        while (!attente.isEmpty()) {
            Boulevard courant = getMin(attente);
            attente.remove(courant);
            courant.marque = true;
            for (Arc a : courant.arc) {
                Boulevard succ = a.Boulevardsuiv;
                if (!succ.marque) {
                    int nouveauTemps = courant.temps + a.temps;
                    if (nouveauTemps  < succ.temps) {
                        succ.temps = nouveauTemps;
                        succ.arcPred = a;
                        if (!attente.contains(succ)) {
                            attente.add(succ);
                        }
                    }
                }
            }
        }
    }

    public void afficherChemin(Boulevard destination) {
        if (destination == null) {
            System.out.println("Boulevard introuvable.");
            return;
        }
        if (destination.temps == Integer.MAX_VALUE) {
            System.out.println("Aucun chemin trouvé jusqu’à " + destination.nom);
            return;
        }
        ArrayList<String> chemin = new ArrayList<>();
        Boulevard courant = destination;

        while (courant != null) {
            chemin.add(0, courant.nom); // On ajoute au début pour inverser l’ordre
            if (courant.arcPred != null)
                courant = courant.arcPred.Boulevardprec;
            else
                break;
        }
        System.out.println("Chemin le plus court :");
        for (int i = 0; i < chemin.size(); i++) {
            System.out.print(chemin.get(i));
            if (i < chemin.size() - 1) System.out.print(" -> ");
        }
        System.out.println("\nTemps total : " + destination.temps);
    }

    public Boulevard getMin(ArrayList<Boulevard> liste) {
        Boulevard min = null;
        int meilleurTemps = Integer.MAX_VALUE;

        for (Boulevard b : liste) {
            if (b.temps < meilleurTemps) {
                meilleurTemps = b.temps;
                min = b;
            }
        }
        return min;
    }

    public Arc getMinArc(Boulevard b) {
        Arc minArc = b.arc.get(0);
        for (Arc a : b.arc) {
            if (a.temps < minArc.temps) {
                minArc = a;
            }
        }
        return minArc;
    }

    //première version avec Djirka
    public void Parcours(HashMap<String, Boulevard> ville, Boulevard source) {
        Boulevard courant = source;
        int tempsTotal = 0;

        ArrayList<String> cheminGlobal = new ArrayList<>();
        cheminGlobal.add(courant.nom);

        ArrayList<Arc> demandes = new ArrayList<>();
        for (Boulevard b : ville.values()) {
            for (Arc a : b.arc) {
                if (Boolean.TRUE.equals(a.demande)) {
                    demandes.add(a);
                }
            }
        }

        while (!demandes.isEmpty()) {

            dijkstra(ville, courant);
            Arc meilleureRue = TrouverMeilleurTemps(demandes);
            if (meilleureRue == null) {
                System.out.println("Impossible d'atteindre toutes les rues en demande.");
                break;
            }

            Boulevard departRue = meilleureRue.Boulevardprec;
            Boulevard arriveeRue = meilleureRue.Boulevardsuiv;

            ArrayList<String> sousChemin = reconstruireChemin(departRue);

            if (sousChemin.isEmpty()) {
                System.out.println("Erreur : impossible de rejoindre " + departRue.nom);
                break;
            }

            for (int i = 1; i < sousChemin.size(); i++) {
                cheminGlobal.add(sousChemin.get(i));
            }

            if (!cheminGlobal.get(cheminGlobal.size() - 1).equals(arriveeRue.nom)) {
                cheminGlobal.add(arriveeRue.nom);
            }

            tempsTotal += departRue.temps + meilleureRue.temps;

            demandes.remove(meilleureRue);
            meilleureRue.demande = false;

            courant = arriveeRue;
        }

        if (!courant.equals(source)) {
            dijkstra(ville, courant);
            ArrayList<String> retour = reconstruireChemin(source);

            if (!retour.isEmpty()) {
                for (int i = 1; i < retour.size(); i++) {
                    cheminGlobal.add(retour.get(i));
                }
                tempsTotal += source.temps; // source.temps après Dijkstra(courant)
            }
        }

        System.out.println("Chemin global :");
        for (int i = 0; i < cheminGlobal.size(); i++) {
            System.out.print(cheminGlobal.get(i));
            if (i < cheminGlobal.size() - 1) System.out.print(" -> ");
        }
        System.out.println("\nTemps total : " + tempsTotal);
    }

    public Arc TrouverMeilleurTemps(ArrayList<Arc> demandes){
        Arc meilleureRue = null;
        Boulevard departRue = null;
        int meilleurTemps = Integer.MAX_VALUE;

        for (Arc a : demandes) {
            Boulevard prec = a.Boulevardprec;

            if (prec.temps == Integer.MAX_VALUE) {
                continue;
            }
            int cout = prec.temps;
            if (cout < meilleurTemps) {
                meilleurTemps = cout;
                meilleureRue = a;
                departRue = prec;

            }
        }
        return meilleureRue;
    }

    private ArrayList<String> reconstruireChemin(Boulevard destination) {
        ArrayList<String> chemin = new ArrayList<>();

        if (destination == null || destination.temps == Integer.MAX_VALUE) {
            return chemin; // chemin vide = inatteignable
        }

        Boulevard courant = destination;
        while (courant != null) {
            chemin.add(0, courant.nom); // on ajoute au début pour inverser
            if (courant.arcPred != null) {
                courant = courant.arcPred.Boulevardprec;
            } else {
                break;
            }
        }

        return chemin;
    }




    private ArrayList<Boulevard> getPointsCollecte(HashMap<String, Boulevard> ville) {
        ArrayList<Boulevard> points = new ArrayList<>();
        for (Boulevard b : ville.values()) {
            if (b.ptDeCollecte) {
                points.add(b);
            }
        }
        return points;
    }


    private int[] construireMST(int[][] dist, int racine) {
        int n = dist.length;
        int[] parent = new int[n];          // parent[i] = père de i dans l'arbre
        int[] cle = new int[n];             // poids minimal pour raccorder i
        boolean[] dansMST = new boolean[n];

        Arrays.fill(cle, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);
        cle[racine] = 0;

        for (int k = 0; k < n - 1; k++) {
            int u = -1;
            int min = Integer.MAX_VALUE;

            // choisir le sommet non encore pris avec la plus petite clé
            for (int i = 0; i < n; i++) {
                if (!dansMST[i] && cle[i] < min) {
                    min = cle[i];
                    u = i;
                }
            }

            if (u == -1) break; // graph non connexe (sécurité)

            dansMST[u] = true;

            // mise à jour des voisins
            for (int v = 0; v < n; v++) {
                if (!dansMST[v] && dist[u][v] < cle[v]) {
                    cle[v] = dist[u][v];
                    parent[v] = u;
                }
            }
        }

        return parent;
    }

    private void dfsMST(int u,
                        ArrayList<ArrayList<Integer>> adj,
                        boolean[] visite,
                        ArrayList<Integer> ordre) {
        visite[u] = true;
        ordre.add(u); // préfixe : on ajoute le sommet dès son entrée

        for (int v : adj.get(u)) {
            if (!visite[v]) {
                dfsMST(v, adj, visite, ordre);
            }
        }
    }


    public ArrayList<String> tourneeMST(HashMap<String, Boulevard> ville, Boulevard depot) {
        int tempsTotal = 0;
        int nbAretes = 0;

        ArrayList<Boulevard> points = getPointsCollecte(ville);

        // S'assurer que le dépôt est dans la liste en première position
        int indexDepot = -1;
        for (int i = 0; i < points.size(); i++) {
            if (points.get(i) == depot) {
                indexDepot = i;
                break;
            }
        }
        if (indexDepot == -1) {
            points.add(0, depot);
        } else if (indexDepot != 0) {
            Collections.swap(points, 0, indexDepot);
        }

        int n = points.size();
        if (n <= 1) {
            return new ArrayList<>();
        }

        // 2. Matrice des plus courts chemins entre tous les points
        int[][] dist = new int[n][n];

        for (int i = 0; i < n; i++) {
            Boulevard source = points.get(i);
            dijkstra(ville, source);  // met à jour .temps / .arcPred pour tous les boulevards

            for (int j = 0; j < n; j++) {
                Boulevard dest = points.get(j);
                dist[i][j] = dest.temps;
            }
        }

        // 3. Construire le MST avec Prim en prenant 0 (le dépôt) comme racine
        int[] parent = construireMST(dist, 0);

        // 4. Transformer parent[] en liste d’adjacence
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int v = 0; v < n; v++) {
            if (parent[v] != -1) {
                int p = parent[v];
                adj.get(p).add(v);
                adj.get(v).add(p); // l’arbre est non orienté
            }
        }

        // 5. Parcours préfixe du MST à partir du dépôt (0)
        boolean[] visite = new boolean[n];
        ArrayList<Integer> ordre = new ArrayList<>();
        dfsMST(0, adj, visite, ordre);

        // 6. Construire la tournée réelle dans le graphe de rues
        ArrayList<String> cheminGlobal = new ArrayList<>();
        Boulevard courant = depot;

        for (int k = 1; k < ordre.size(); k++) {
            int idx = ordre.get(k);
            Boulevard cible = points.get(idx);

            if (cible == courant) continue;

            // plus court chemin courant -> cible
            dijkstra(ville, courant);
            ArrayList<String> sousChemin = reconstruireChemin(cible);

            // Calculer temps et nombre d'arêtes du sous-chemin
            for (int x = 0; x < sousChemin.size() - 1; x++) {
                Boulevard u = ville.get(sousChemin.get(x));
                Boulevard v = ville.get(sousChemin.get(x + 1));

                // Trouver l'arc correspondant u -> v
                for (Arc a : u.arc) {
                    if (a.Boulevardsuiv == v) {
                        tempsTotal += a.temps;
                        nbAretes++;
                        break;
                    }
                }
            }


            // enlever le premier sommet pour éviter les doublons
            if (!cheminGlobal.isEmpty() && !sousChemin.isEmpty()) {
                sousChemin.remove(0);
            }

            cheminGlobal.addAll(sousChemin);
            courant = cible;
        }

        // retour au dépôt
        dijkstra(ville, courant);
        ArrayList<String> retour = reconstruireChemin(depot);
        for (int x = 0; x < retour.size() - 1; x++) {
            Boulevard u = ville.get(retour.get(x));
            Boulevard v = ville.get(retour.get(x + 1));

            for (Arc a : u.arc) {
                if (a.Boulevardsuiv == v) {
                    tempsTotal += a.temps;
                    nbAretes++;
                    break;
                }
            }
        }

        if (!retour.isEmpty()) retour.remove(0);
        System.out.println("Temps total de la tournée (MST) : " + tempsTotal + " unités");
        System.out.println("Nombre total d'arêtes parcourues : " + nbAretes);

        cheminGlobal.addAll(retour);

        return cheminGlobal;
    }


public void afficher_Chemin(LinkedList<Arc> parcour) {
        for (Arc element : parcour) {
            System.out.println(element.nom);
        }
    }
    public void afficher_Chemin2(ArrayList<Arc> parcour) {
        for (Arc element : parcour) {
            System.out.println(element.nom);
        }
    }

    public LinkedList<Arc> eulerien(Boulevard depart, HashMap<String, Boulevard> graph) {
        // Calcul des degrés entrants et sortants
        Map<Boulevard, Integer> inDegree = new HashMap<>();
        Map<Boulevard, Integer> outDegree = new HashMap<>();

        // Vérification des conditions pour un graphe eulérien
        for (Boulevard b : graph.values()) {
            int in = inDegree.getOrDefault(b, 0);
            int out = outDegree.getOrDefault(b, 0);
            if (in != out) {
                System.err.println("Erreur : le graphe n'est pas eulérien (aucun circuit eulérien possible).");
                return null;
            }
        }

        // Algorithme d’Hierholzer
        Stack<Arc> pileArcs = new Stack<>();
        Stack<Boulevard> pile = new Stack<>();
        LinkedList<Arc> resultat = new LinkedList<>();
        Map<Boulevard, LinkedList<Arc>> restants = new HashMap<>();

        for (Boulevard b : graph.values()) {
            restants.put(b, new LinkedList<>(b.arc));
        }

        pile.push(depart);

        while (!pile.isEmpty()) {
            Boulevard courant = pile.peek();
            restants.putIfAbsent(courant, new LinkedList<>(courant.arc));
            LinkedList<Arc> liste = restants.get(courant);
            if (!liste.isEmpty()) {
                Arc arc = liste.removeFirst();
                pile.push(arc.Boulevardsuiv);
                pileArcs.push(arc);
                //  Si cet arc représente une arête
                // alors on supprime immédiatement son arc inverse dans la liste des restants
                if (arc.simpleEtSensDouble) {
                    Boulevard src = arc.Boulevardprec;
                    Boulevard dst = arc.Boulevardsuiv;

                    // chercher l'arc inverse et le supprimer
                    LinkedList<Arc> listDst = restants.get(dst);
                    if (listDst != null) {
                        Arc inverseToRemove = null;
                        for (Arc candidate : listDst) {

                            if (candidate.Boulevardsuiv == src) {
                                inverseToRemove = candidate;
                                break;
                            }
                        }
                        if (inverseToRemove != null) {
                            listDst.remove(inverseToRemove);
                        }
                    }
                }
            } else {
                pile.pop();
                if (!pileArcs.isEmpty()) {
                    resultat.addFirst(pileArcs.pop());
                }
            }
        }

        return resultat;
    }


    public LinkedList<Arc> semi_Eulerien(Boulevard depart, HashMap<String, Boulevard> graph) {
        // Calcul des degrés entrants et sortants
        Map<Boulevard, Integer> inDegree = new HashMap<>();
        Map<Boulevard, Integer> outDegree = new HashMap<>();

        for (Boulevard b : graph.values()) {
            outDegree.put(b, b.arc.size());
            inDegree.putIfAbsent(b, 0); // init si pas encore présent
            for (Arc a : b.arc) {
                inDegree.put(a.Boulevardsuiv, inDegree.getOrDefault(a.Boulevardsuiv, 0) + 1);
                outDegree.putIfAbsent(a.Boulevardsuiv, 0);
            }
        }

        // Vérification des conditions pour un chemin eulérien
        Boulevard start = null;
        Boulevard end = null;
        for (Boulevard b : graph.values()) {
            int in = inDegree.getOrDefault(b, 0);
            int out = outDegree.getOrDefault(b, 0);
            if (out - in == 1) {
                if (start != null) { // il ne peut y avoir qu'un point de départ
                    System.err.println("Erreur : le graphe n'est pas semi-eulérien");
                    return null;
                }
                start = b;
            } else if (in - out == 1) {
                if (end != null) { // il ne peut y avoir qu'un point d'arrivée
                    System.err.println("Erreur : le graphe n'est pas semi-eulérien");
                    return null;
                }
                end = b;
            } else if (in != out) {
                System.err.println("Erreur : le graphe n'est pas semi-eulérien");
                return null;
            }
        }

        if (start == null) start = depart; // si circuit eulérien, on peut partir de n'importe où

        // Algorithme d’Hierholzer
        Stack<Arc> pileArcs = new Stack<>();
        Stack<Boulevard> pile = new Stack<>();
        LinkedList<Arc> resultat = new LinkedList<>();
        Map<Boulevard, LinkedList<Arc>> restants = new HashMap<>();

        pile.push(start);
        restants.put(start, new LinkedList<>(start.arc));

        while (!pile.isEmpty()) {
            Boulevard courant = pile.peek();
            restants.putIfAbsent(courant, new LinkedList<>(courant.arc));
            LinkedList<Arc> liste = restants.get(courant);

            if (!liste.isEmpty()) {
                Arc arc = liste.removeFirst();
                pile.push(arc.Boulevardsuiv);
                pileArcs.push(arc);
            } else {
                pile.pop();
                if (!pileArcs.isEmpty()) {
                    resultat.addFirst(pileArcs.pop());
                }
            }
        }

        return resultat;
    }



    public Boulevard getMin(ArrayList<Boulevard> liste) {
        Boulevard min = null;
        int meilleurTemps = Integer.MAX_VALUE;

        for (Boulevard b : liste) {
            if (b.temps < meilleurTemps) {
                meilleurTemps = b.temps;
                min = b;
            }
        }
        return min;
    }

    public static class PathResult {
        public int distance;
        public List<Arc> path;
        public PathResult(int distance, List<Arc> path) {
            this.distance = distance;
            this.path = path;
        }
    }

    // ===================================================================
    //                      POSTIER CHINOIS COMPLET
    // ===================================================================

    public LinkedList<Arc> postierChinois(HashMap<String, Boulevard> graph, Boulevard start) {

        // calcul des degres
        Map<Boulevard, Integer> inDegree = new HashMap<>();
        Map<Boulevard, Integer> outDegree = new HashMap<>();
        computeDegrees(graph, inDegree, outDegree);

        // prise en compte des desequilibres
        List<Boulevard> surplusOut = new ArrayList<>();
        List<Boulevard> surplusIn = new ArrayList<>();
        findImbalancedVertices(inDegree, outDegree, surplusOut, surplusIn);
        // Si deja equilibré
        if (surplusOut.isEmpty()) {
            return hierholzer(start, graph, new ArrayList<>());
        }
        //determine les chemins supplementaire pour equilibre le graph
        List<List<Arc>> duplicatePaths =
                matchImbalances(surplusOut, surplusIn, graph);
        // fusionne les chinmin pour equilibrer le graph
        List<Arc> extraArcs = new ArrayList<>();
        for (List<Arc> path : duplicatePaths) {
            for (Arc a : path) {
                Arc copy = new Arc();
                copy.nom = a.nom;
                copy.temps = a.temps;
                copy.tonne = a.tonne;
                copy.Boulevardprec = a.Boulevardprec;
                copy.Boulevardsuiv = a.Boulevardsuiv;
                extraArcs.add(copy);
            }
        }
        for (Arc a : extraArcs) {
            a.Boulevardprec.arc.add(a);
        }
        //applique hierholser sur le graph equilibre
        return hierholzer(start, graph,extraArcs);
    }



// ===================================================================
//                           DEGRÉS
// ===================================================================

    private void computeDegrees(HashMap<String, Boulevard> graph,
                                Map<Boulevard, Integer> inDegree,
                                Map<Boulevard, Integer> outDegree) {

        for (Boulevard b : graph.values()) {
            outDegree.put(b, b.arc.size());
            inDegree.putIfAbsent(b, 0);

            for (Arc a : b.arc) {
                Boulevard v = a.Boulevardsuiv;
                inDegree.put(v, inDegree.getOrDefault(v, 0) + 1);
                outDegree.putIfAbsent(v, 0);
            }
        }
        /*
        System.out.println("=== DEGRES ===");
        for (Boulevard b : graph.values()) {
            int tot = inDegree.get(b)+ outDegree.get(b);
            System.out.println(b.nom + "  IN=" + inDegree.get(b) + "  OUT=" + outDegree.get(b)+ "  TOT="+ tot);
        }

         */
    }



// ===================================================================
//                   RECHERCHE DES DÉSÉQUILIBRES
// ===================================================================

    private void findImbalancedVertices(Map<Boulevard, Integer> inDegree,
                                        Map<Boulevard, Integer> outDegree,
                                        List<Boulevard> surplusOut,
                                        List<Boulevard> surplusIn) {

        for (Boulevard b : inDegree.keySet()) {
            int in = inDegree.get(b);
            int out = outDegree.get(b);

            if (out > in) {
                for (int k = 0; k < out - in; k++) surplusOut.add(b);
            } else if (in > out) {
                for (int k = 0; k < in - out; k++) surplusIn.add(b);
            }
        }
        /*
        System.out.println("=== SURPLUS OUT ===");
        for (Boulevard b : surplusOut) System.out.println(b.nom);

        System.out.println("=== SURPLUS IN ===");
        for (Boulevard b : surplusIn) System.out.println(b.nom);
         */
    }



// ===================================================================
//                 DIJKSTRA AVEC PARENTS & ARC UTILISÉ
// ===================================================================

    private Map<Boulevard, Boulevard> parentsDijkstra;
    private Map<Boulevard, Arc> arcUsedDijkstra;

    public void dijkstraWithParents(HashMap<String, Boulevard> ville, Boulevard source) {

        parentsDijkstra = new HashMap<>();
        arcUsedDijkstra = new HashMap<>();

        for (Boulevard b : ville.values()) {
            b.temps = Integer.MAX_VALUE;
            b.marque = false;
        }

        source.temps = 0;

        ArrayList<Boulevard> Q = new ArrayList<>();
        Q.add(source);

        while (!Q.isEmpty()) {
            Boulevard courant = getMin(Q);
            Q.remove(courant);
            courant.marque = true;

            for (Arc a : courant.arc) {
                Boulevard succ = a.Boulevardsuiv;
                if (succ.marque) continue;

                int newCost = courant.temps + a.temps;
                if (newCost < succ.temps) {
                    succ.temps = newCost;
                    parentsDijkstra.put(succ, courant);
                    arcUsedDijkstra.put(succ, a);
                    if (!Q.contains(succ)) Q.add(succ);
                }
            }
        }
    }




    // Reconstruction d’un chemin
    private List<Arc> reconstruireChemin(Boulevard source, Boulevard target) {

        LinkedList<Arc> path = new LinkedList<>();

        Boulevard cur = target;
        while (cur != null && !cur.equals(source)) {
            Arc a = arcUsedDijkstra.get(cur);
            if (a == null) return new ArrayList<>();
            path.addFirst(a);
            cur = parentsDijkstra.get(cur);
        }

        return path;
    }



// ===================================================================
//     CALCUL OPTIMISÉ DES PLUS COURTS CHEMINS (IN → OUT UNIQUEMENT)
// ===================================================================

    private Map<Boulevard, Map<Boulevard, PathResult>>
    computeTargetedShortestPaths(
            List<Boulevard> surplusIn,
            List<Boulevard> surplusOut,
            HashMap<String, Boulevard> graph) {

        Map<Boulevard, Map<Boulevard, PathResult>> result = new HashMap<>();

        for (Boulevard source : surplusIn) {

            // Lancer Dijkstra uniquement depuis ce sommet
            dijkstraWithParents(graph, source);

            Map<Boulevard, PathResult> mapToTargets = new HashMap<>();

            // Extraire uniquement les distances utiles
            for (Boulevard target : surplusOut) {

                if (target.temps == Integer.MAX_VALUE) continue;

                List<Arc> path = reconstruireChemin(source, target);
                mapToTargets.put(target,
                        new PathResult(target.temps, path));
            }

            result.put(source, mapToTargets);
        }

        return result;
    }



// ===================================================================
//     APARIEMENT OPTIMAL AVEC LE NOUVEAU CALCUL DES CHEMINS
// ===================================================================

    private List<List<Arc>> matchImbalances(
            List<Boulevard> surplusOut,
            List<Boulevard> surplusIn,
            HashMap<String, Boulevard> graph) {

        // Calcul optimisé IN → OUT uniquement
        Map<Boulevard, Map<Boulevard, PathResult>> shortestPaths =
                computeTargetedShortestPaths(surplusIn, surplusOut, graph);

        int n = surplusIn.size();
        final int INF = 1_000_000_000;
        int[][] cost = new int[n][n];

        // Construction de la matrice de coût pour Hungarian
        for (int i = 0; i < n; i++) {
            Boulevard from = surplusIn.get(i);
            var sp = shortestPaths.get(from);

            for (int j = 0; j < n; j++) {
                Boulevard to = surplusOut.get(j);

                if (sp == null || !sp.containsKey(to)
                        || sp.get(to).path.isEmpty()) {
                    cost[i][j] = INF;
                } else {
                    cost[i][j] = sp.get(to).distance;
                }
            }
        }

        // Appariement optimal
        int[] assignment = hungarian(cost);

        List<List<Arc>> results = new ArrayList<>();

        for (int j = 0; j < n; j++) {
            int i = assignment[j];

            Boulevard from = surplusIn.get(i);
            Boulevard to = surplusOut.get(j);

            PathResult pr = shortestPaths.get(from).get(to);
            System.out.println(from.nom + " -> " + to.nom);
            if (pr != null) {
                results.add(pr.path);
            }

        }
        /*
        // Affichage détaillé (facultatif)
        int matchNum = 1;
        for (List<Arc> path : results) {
            System.out.println("Chemin " + matchNum + " :");

            if (path.isEmpty()) {
                System.out.println("  Pas de chemin disponible");
            } else {
                Boulevard current = path.get(0).Boulevardprec;
                System.out.println("  Départ : " + current.nom);

                for (Arc a : path) {
                    System.out.println("    -> " + a.nom
                            + " (de " + a.Boulevardprec.nom
                            + " à " + a.Boulevardsuiv.nom
                            + ", temps : " + a.temps + ")");
                    current = a.Boulevardsuiv;
                }

                System.out.println("  Arrivée : " + current.nom);
            }

            matchNum++;
            System.out.println();
        }
         */

        return results;
    }



// ===================================================================
//               ALGORITHME DE HIERHOLZER (FINAL)
// ===================================================================

    private LinkedList<Arc> hierholzer(Boulevard start,
                                       HashMap<String, Boulevard> graph,
                                       List<Arc> extraArcs) {

        Map<Boulevard, LinkedList<Arc>> restants = new HashMap<>();

        for (Boulevard b : graph.values()) {
            restants.put(b, new LinkedList<>(b.arc));
        }

        Stack<Boulevard> pile = new Stack<>();
        Stack<Arc> pileArcs = new Stack<>();
        LinkedList<Arc> resultat = new LinkedList<>();

        pile.push(start);

        while (!pile.isEmpty()) {
            System.out.println("--");
            Boulevard courant = pile.peek();
            LinkedList<Arc> list = restants.get(courant);

            if (list != null && !list.isEmpty()) {
                Arc a = list.removeFirst();
                pile.push(a.Boulevardsuiv);
                pileArcs.push(a);
            } else {
                pile.pop();
                if (!pileArcs.isEmpty())
                    resultat.addFirst(pileArcs.pop());
            }
        }

        return resultat;
    }



// ===================================================================
//                     HUNGARIAN ALGORITHM COMPLET
// ===================================================================

    public int[] hungarian(int[][] cost) {
        int n = cost.length;
        int m = cost[0].length;

        int[] u = new int[n + 1];
        int[] v = new int[m + 1];
        int[] p = new int[m + 1];
        int[] way = new int[m + 1];

        for (int i = 1; i <= n; i++) {
            p[0] = i;
            int j0 = 0;
            int[] minv = new int[m + 1];
            boolean[] used = new boolean[m + 1];

            Arrays.fill(minv, Integer.MAX_VALUE);

            do {
                used[j0] = true;
                int i0 = p[j0];
                int delta = Integer.MAX_VALUE;
                int j1 = 0;

                for (int j = 1; j <= m; j++) {
                    if (!used[j]) {
                        int cur = cost[i0 - 1][j - 1] - u[i0] - v[j];
                        if (cur < minv[j]) {
                            minv[j] = cur;
                            way[j] = j0;
                        }
                        if (minv[j] < delta) {
                            delta = minv[j];
                            j1 = j;
                        }
                    }
                }

                for (int j = 0; j <= m; j++) {
                    if (used[j]) {
                        u[p[j]] += delta;
                        v[j] -= delta;
                    } else {
                        minv[j] -= delta;
                    }
                }

                j0 = j1;
            } while (p[j0] != 0);

            do {
                int j1 = way[j0];
                p[j0] = p[j1];
                j0 = j1;
            } while (j0 != 0);
        }

        int[] assignment = new int[m];
        for (int j = 1; j <= m; j++) {
            assignment[j - 1] = p[j] - 1;
        }
        return assignment;
    }

}


